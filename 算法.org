* 基础知识
  数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。
  数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。
  数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。
  数据项：一个数据元素可以由若干个数据项组成。数据项是数据的不可分割的最小单位。
  数据对象：是性质相同的数据元素的集合，是数据的子集。
  数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。
  数据结构可分为逻辑结构和物理结构。
  逻辑结构：是指数据对象中数据元素之间的相互关系。有以下四种结构：
  - 线性结构：线性结构中的数据元素之间是一对一的关系。
  - 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。
  - 图形结构：图形结构的数据元素是多对多的关系。
  - 集合结构：集合结构的数据元素除了同属于一个集合外，它们之间没有其他关系。
  逻辑结构是针对具体问题的，是为了解决某个问题。在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。
  物理结构，也叫做存储结构，是指数据的逻辑结构在计算机中的存储形式。数据的存储结构应正确反映数据元素之间的逻辑关系。
  数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

  从程序角度：编程 = 数据结构 + 算法 + 程序设计语言
  从软件工程角度： 还需加上 项目管理、质量管理、代码规范等
** 常用算法
   算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。
   算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。
*** 递推算法
    通过已知条件，利用特定关系得出中间推论，逐步递推，直至得到结果为止。利用现有信息得到新的信息是递推算法的核心。
    递推算法可分为顺推法和逆推法两种。
    1. 顺推法
       从已知条件出发，逐步推算出要解决问题的方法。
    2. 逆推法
       从已知的结果出发，用迭代表达式逐步推算出问题开始的条件，即顺推法的逆过程。
*** 枚举法
    也称为穷举法。在解决某些问题时，可能没有办法按一定的规律从众多的候选答案中找出正确的解，可使用循环语句和条件语句逐步验证候选答案的正确性，从而得到正确的答案。主要利用计算机的高速运算性能。
*** 递归算法
    一种直接或间接的调用自身的算法。
    递归算法的具体实现过程一般是通过函数或子过程来完成，在函数或子过程的内部，编写代码直接或间接的调用自身，即可完成递归操作。其实质是将求解的问题转化为规模缩小的同类问题的子问题。以小化大，分而治之。
*** 贪婪算法
    总是做出在当前看来最好的选择，做出局部最优解，意在局部最优（贪婪）达到全局最优。
    思路：从问题的某一个初始解出发逐步逼近给定的目标，以尽可能块的求得更好地解。当达到算法中的某一步不能再继续前进时，就停止算法，给出近似解。不回溯。
*** 试探法
    也称为回溯法，是一种系统的搜索问题解的方法。典型场景：下棋
*** 模拟算法
   使用计算机模拟生成日常生活中的相关数据。
   在程序设计语言中，可使用随机函数来模拟自然界中发生的不可预测情况。C语言中使用srand()和rand()函数生成随机数。其中srand用来初始化随机数发生器，然后使用rand()函数生成随机数，要使用这两个函数，需要在源程序中包含time.h头文件。
** 算法的评价
   四原则：
   正确性，高效性，健壮性，可读性。高效性是主要标准。
   通常认为，一个算法的“工作量”可以靠代码中的关键部分来确定，这些关键部分称为基本操作，通过统计算法中基本操作重复执行的次数就可近似地得到算法的执行效率，用O(n)表示，称为时间复杂度。
   算法时间复杂度定义：
   在进行算法分析时，语句总的执行次数T(n)时关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。这样用大写O()来体现算法时间复杂度的记法，称为大O记法。
   推导大O阶方法：
   1. 用常数1取代运行时间中的所有加法常数。
   2. 在修改后的运行次数函数中，只保留最高阶项。
   3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。
   得到的结果就是大O阶。
注：在分析一个算法的时间复杂度时，一般可考虑平均情况和最坏情况。对于时间复杂度的平均值，往往需要较复杂的统计计算。因此大部分情况下都以最坏时间复杂度为准来考查算法的时间复杂度。
* 简单数据结构
  算法用来处理对应的数据，被处理的数据都必须按一定的规则进行组织。当数据之间存在一种或多种特定关系时，称这些关系为结构。
** 最基本的数据结构：线性表
   线性表是一个线性结构，它是一个含有n个结点（数据元素）的有限序列，不同线性表的数据元素可以不同，但同一线性表，各数据元素必须具有相同的数据类型，数据元素长度相同。
   特征：
   + 有且只有一个首元素
   + 有且只有一个尾元素
   + 除尾元素外，其余元素均有唯一的后继元素
   + 除首元素外，其余元素均有唯一的前驱元素
   在计算机中保存线性表时，根据存储方式的不同，分为顺序存储结构和链式存储结构。顺序存储结构的称为顺序表，链式存储结构的称为链表。
*** 顺序表
    用一组地址连续的存储单元依次保存线性表中的数据元素。
    特点：易于访问，不易控制。
*** 链表
    采用动态存储分配的一种结构，可以根据需要申请内存单元。C语言中可以用malloc函数动态分配结点，删除结点时，使用free函数释放内存空间。
    注：C语言不支持自动回收动态分配到空间。
    为了表示每个数据元素与其直接后继数据元素之间的逻辑关系，对任一数据元素来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素的存储映像，称为结点（Node）。n个结点链结成一个链表。即为线性表的链式存储结构。
    把链表中第一个结点的存储位置叫做头指针。有时，我们为了更加方便的对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。
    特点：易于操作，不易访问。
*** 静态链表
    用数组描述的链表叫做静态链表，这种描述方法也叫做游标实现法。主要用于给没有指针和引用的程序语言的一种实现单链表的方法。
    数组的第一个和最后一个元素作为特殊元素处理，不存数据。通常把未被使用的数组元素称为备用链表。而数组第一个元素，即下标为0的元素的cur（游标）存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点的作用。
** 先进先出结构：队列
   队列是一种特殊的线性表，只允许在表的前端(队头,front)进行删除操作，在表的后端(队尾,rear)进行插入操作。当队列中没有元素时，称为空队列。队列是一种先进先出(Firest in Firest Out)的线性表，简称FIFO。
   循环队列满的条件：(rear+1) % QueueSize == front
        其空的条件：front == rear
   循环队列的长度公式：(rear - front + QueueSize) % QueueSize
** 后进先出结构：栈
   栈是一种特殊的线性表，只能在一端进行操作，称为栈顶，另一端称为栈底。栈又称为后进先出(Last in Firest Out)的线性表，简称LIFO结构。
** 串
   串（string）是由零个或多个字符组成的有限序列，又叫字符串。
   串中的字符数目n称为串的长度。零个字符的串称为空串（null string）。
   子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。
   子串在主串中的位置是子串的第一个字符在主串中的序号。
   KMP模式匹配算法
* 复杂数据结构
** 层次关系结构：树
   一个结点有一个前驱和多个后继。树（Tree）是n(n \ge 0)个结点的集合，集合中有一个称为根（root）的特殊结点，在根结点下分布着一些互不相交的集合，每一个集合又是一个树，称为根结点的子树。n=0时称为空树。
   在一棵树中，有且仅有一个结点没有前驱，这个结点就是树的根结点。
   除根结点外，其余每个结点有且仅有一个前驱。
   每个结点可以有任意多个后继。
   相关术语：
   - 父结点/子结点/兄弟结点：每个结点的子树的根称为该结点的子结点，相应的，该结点被称为子结点的父结点，具有同一父结点的结点称为兄弟结点。
   - 结点的度：结点拥有的子树的数量称为该结点的度。
   - 树的度：指该树中结点的最大度数。
   - 叶结点和分支结点：树中度为零的结点称为叶结点或终端结点，度不为零的结点称为分支结点或非终端结点。
   - 结点的层数：结点的层数从树根开始计算。
   - 树的深度：一棵树中结点的最大层数称为树的深度。
   - 有序树和无序树：树中各结点的子树（兄弟结点）是按一定次序从左向右排列的，称为有序树，否则称为无序树。
   - 森林：森林（forest）是m（m>0）棵互不相交的树的集合。
** 二叉树
    任意结点最多只能有两个子结点的树称为二叉树。
    二叉树与树的两个主要区别：
    - 树中结点的最大度数没有限制，而二叉树结点的最大度数为2
    - 树的结点无左右之分，而二叉树的结点有左右之分，是有序树。
    两个特殊类型的二叉树：
    - 满二叉树：在二叉树中，除最下一层的叶结点外，每次的结点都有2股子结点，就构成了满二叉树。
    - 完全二叉树：除二叉树最后一层外，其他各层的结点数都达到最大个数，且最后一层从左向右的叶结点连续存在，只缺右侧若干结点，就是完全二叉树。
    满二叉树是完全二叉树，而完全二叉树不一定是满二叉树。
*** 性质
    1. 在二叉树中，第i层的结点总数最多有2i-1个结点。
    2. 深度为k的二叉树最多有2k-1个结点(k \ge 1)，最少有k个结点。
    3. 对于一颗二叉树，如果其叶结点数为n0，而度为2的结点总数为n2，则n0=n2+1。
    4. 具有n个结点的完全二叉树的深度k为[log2n]+1。
    5. 有n个结点的完全二叉树各结点如果用顺序存储，对任意结点i，有如下关系：
       - 如果i \ne 1，则其父结点的编号为i/2;
       - 如果2*i \le n，则其左子树根结点的编号为2*i，若2*i > n，则无左子树；
       - 如果2*i+1 \le n，则其右子树根结点的编号为2*i+1，若2*i+1 > n，则无右子树。
*** 存储
    有两种存储结构，顺序存储结构和链式存储结构。顺序存储适合完全二叉树。
*** 遍历二叉树
    按一定的规则和顺序走遍二叉树的所有子树，使每一个结点都被访问一次，而且只被访问一次。
    D表示根结点，L表示左子树/R表示右子树，对其遍历有三种方式:
    - 先序遍历（DLR）：称为先根次序遍历，即先访问根结点，再按先序遍历左子树，最后按先序遍历右子树。
    - 中序遍历（LDR）：称为中根次序遍历，即先按中序遍历左子树，再访问根结点，最后按中序遍历右子树。
    - 后序遍历（LRD）：称为后根次序遍历，即先按后序遍历左子树，在按后序遍历右子树，最后访问根结点。
*** 线索二叉树
    由二叉树的性质可知，对于一颗具有n个结点的二叉树，对应的二叉链表中共有2n个指针域，其中n-1个用于指向除根结点外的n-1个结点，另外n+1个指针域为空。可以利用二叉链表中的这些空指针域来存放结点的前驱和后继。将每个结点中空的左指针域或右指针域分别用于指向结点的前驱和后继的指针域称为线索，其中，在空的左指针域中存放的指向其前驱结点的指针称为左线索，反之称为右线索。
    这种加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。
    在一个线索二叉树中，为了区别每个结点的左、右指针域所存放的时子树指针，还是线索，必须在结点结构中增加两个标志域：
    一个左线索标志域lflag、另一个是右线索标志域rflag。若某个标志为1，则表示对应的指针域为线索，否则，为子树指针。
    将二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化。按某种遍历次序将二叉树线索化的实质是：按该次序遍历二叉树，在遍历过程中用线索取代空指针。
*** 赫夫曼树
    从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度。树的路径长度就是从树根到每一个结点的路径长度之和。
    对于带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。带权路径长度WPL最小的二叉树称作赫夫曼树，也称为最优二叉树。
** 图
*** 定义
    图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E),其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。
    无向边：若顶点v_i 到v_j 之间的边没有方向，则称这条边为无向边(Edge)，用无序偶对(v_i, V_j)来表示，如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。
    有向边：若从顶点v_i 到v_j 的边有方向，则称这条边为有向边，也称为弧，用有序偶对<v_i, v_j>来表示，v_i 称为弧尾(tail),v_j 称为弧头(head)。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。
    在图中，若被存在顶点到其自身的边，且同一条边被重复出现，则称这样的图为简单图。
    在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有$n*(n-1)/2$。
    在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。
    与图的边或弧相关的数字叫做权（weight），带权的图通常称为网（network）。
    在无向图中，顶点v的度（degree）是和v相关联的边的数目，记为TD(v)。
    在有向图中，以顶点v为头的弧的数目称为v的入度（InDegree）,记为ID(v)，以v为尾的弧的数目称为v的出度（OutDegree），记为OD(v)，顶点v的度为TD(v) = ID(v) + OD(v)。边数为各顶点的入度或出度和。
    从顶点i到顶点j的路径的长度为路径上的边或弧的数目。
    第一个顶点到最后一个顶点相同的路径称为回路或环（Cycle）。顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路，称为简单回路或简单环。
    连通图：在无向图中，如果从顶点v_i 到顶点v_j 有路径，则称v_i 和v_j 是连通的。如果图中任意两点都是连通的，则称G是连通图。
    具有n个顶点的无向图，当有(n-1)(n-2)/2+1条边时即可确保它是一个连通图。
    无向图中的极大连通子图称为连通分量。
    强连通图：在有向图中，如果对于每一对v_i 、v_j, v_i \neq v_j, 从v_i 到v_j 和从v_j 到 v_i 都存在路径，则称G是强连通图。
    判断一个有向图是否强连通，要看从任一顶点出发是否能够回到该顶点。
    有向图中的极大强连通子图称作有向图的强连通分量。
    具有n个顶点的有向图最多有n个强连通分量。
    生成树：连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。
    具有n个顶点和e条边的无向图是一个森林，则该森林有n-e棵树。
    如果一个有向图恰有一个顶点的入度为0，其余顶点的入度为1，则是一颗有向树。一个有向树的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。
*** 图的存储
    邻接矩阵:图的邻接矩阵存储方式是用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵，顶点nxn的方阵）存储图中的边或弧的信息。
    邻接表：将数组与链表相结合的存储方法称为邻接表。
    邻接多重表：适用于边的操作。结构：
    | ivex | ilink | jvex | jlink |
    其中ivex和jvex是与某条边依附的两个顶点在顶点表中的下标。ilink指向依附顶点ivex的下一条边，jlink指向依附顶点的下一条边。这就是邻接多重表结构。
    十字链表：将邻接表与逆邻接表结合起来的链表，适用于有向图。
    其顶点表结构：
    | data | firstin | firstout |
    边表结构：
    | tail | headvex | headlink | taillink |
    其中tailvex是指弧起点在顶点表中的下标，headvex是指弧终点在顶点表中的下标，headlink是指入边表指针域，指向终点相同的下一条边，taillink是指边表指针域，指向起点相同的下一条边。
*** 图的遍历
    从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历。
    深度优先遍历（Depth First Search）也称为深度优先搜索，简称DFS。
    广度优先遍历（Breadth First Search）又称为广度优先搜索，简称BFS。是一种分层的查找过程。
    图的遍历对无向图和有向图都适用。但如果无向图不是连通的，或有向图不是强连通的，调用一次遍历算法只能遍历一个连通分量或强连通分量。按照DFS所访问的顶点和所经过的边的顺序，可得到该连通分量的一颗生成树。
**** 双连通图与关节点
     1. 在无向连通图G中，顶点v被称作一个关节点（或割点），当且仅当删除v以及依附于v的所有边之后，G将被分割成至少两个连通分量。
     2. 一个没有关节点的连通图叫做双连通图。在双连通图上，任何一对顶点间至少存在两条路经，在删去某个顶点及于该顶点相关联的边后，不破坏图的连通性。
     3. 为了找出无向图G的各个双连通分量，可以利用DFS生成树。
        - DFS生成树的根是关节点的充要条件是它至少有两个子女。
        - DFS生成树的叶结点不是关节点。
        - DFS生成树上除叶结点外，其他任一非根顶点u不是关节点的充要条件是，它的子女v可以沿着某条路径通往u的某一祖先。这条路径上的某些边属于图但可以不再DFS生成树上，称这样的边为回边。
**** 如何寻找图的强连通分量
     一个简单O(n^2)的算法是从某个指定顶点v开始使用DFS来标识所有可到达的顶点w，如果某个w有可以回到v的路径，则从v到w的环路上的顶点就构成一个强连通分量；如果所有的w都不能沿着某些边回到v，则v自成一个强连通分量。然后再从不在此强连通分量的某个顶点v开始重复上述工作，直到求出所有顶点所在的强连通分量为止。
*** 最小生成树
    一个连通图的生成树是原图的极小连通子图，它包含原图中的所有顶点，而且有尽可能少的边。
    对于一个连通网络即带权连通图，构成最小生成树的准则有三条：
    1. 有n个顶点的生成树有且仅有n-1条属于该网络的边来联结所有的顶点。
    2. 不能使用产生回路的边。
    3. 树的总代价达到最小，即树中所有边的权值总和达到最小。
**** 构造最小生成树的方法
     1. 避圈法。按边的权值，从小到达依次添加到生成树中，如果构成圈则不选。这类构造最小生成树的方法主要有3种：Prim算法/Kruskal算法和Solin算法。
     2. 破圈法。按边的权值，删除圈中权值最大的边。这类构造最小生成树的方法主要有2种：管梅谷算法和Dijkstra算法。
**** 建立最小生成树的要点
     1. 如果连通带权图中各边上的权值互不相等，构造出来的最小生成树是唯一的；如果存在权值相等的边，若采用邻接表存储，由于选择边的次序不同，构造出来的最小生成树是不唯一的，不过它们总的权值之和应相同。若采用邻接矩阵存储，则结果是唯一的。
     2. 小根堆用于Kruskal算法存储所有的边，是为了选权值最小的边；用于Prim算法，存储从生成树内的顶点到生成树外顶点的所有的边。
*** 最短路径
    最短路径，是指两顶点之间经过的边上的权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点时终点。
    常用算法：Dijkstra算法、Floyd算法。
    Dijkstra是一个按路径长度递增的次序产生最短路径的算法，限制是边上的权值非负。
*** 拓扑排序
    在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网。
    设G=(V,E)是一个具有n个顶点的有向图，v中的顶点序列v_1, v_2, ....,v_n, 满足若从顶点v_i 到v_j 有一条路径，则在顶点序列中顶点v_i 必在顶点v_j 之前，则我们称这样的顶点序列为一个拓扑序列。

* 查找
** 查找概论
   查找表（search table）：是由同一类型的数据元素（或记录）构成的集合。
   关键字（key）：是数据元素中某个数据项的值，又称为键值，有它可以标识一个数据元素。也可以标识一个记录的某个数据项（字段），称为关键码。
   若此关键字可以唯一地标识一个记录，则称此关键子为主关键字（Primary Key）。主关键字所在的数据项称为主关键码。
   可以识别多个数据元素（或记录）的关键字，称为次关键字（Secondary Key），对应的数据项为次关键码。
   查找（searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。
   查找表按照操作方式可分为两大种：静态查找表和动态查找表。
   静态查找表（Static Search Table）:只作查找操作的查找表。它的主要操作有：
   1. 查询某个“特定的”数据元素是否在查找表中。
   2. 检索某个“特定的”数据元素和各种属性。
   动态查找表（Dynamic Search Table）:在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。
** 顺序查找
   顺序查找（Sequential Search）:又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个或最后一个记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个或第一个记录，其关键字和给定值比较都不相等时，则表中没有所查的记录，查找不成功。
** 有序表查找
*** 折半查找
   折半查找（Binary Search）技术:又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找，不断重复上续过程，直到查找成功，或所有查找区域无记录，查找失败为止。
*** 插值查找
    插值查找（Interpolation Search）:是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式$(key-a[low])/(a[hign]-a[log])$。即
    mid=(low+hign)/2 = low + (hign-low)/2 = low + (hign-low)*(key-a[low])/a[hign]-a[low])
*** 斐波那契查找
** 线性索引查找
   索引就是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。
   索引按照结构分为线性索引、树形索引和多级索引。
   线性索引：将索引项集合组织为线性结构，也称为索引表。有三种：稠密索引、分块索引和倒排索引。
*** 稠密索引
    稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项。索引项按照关键码有序排列。
*** 分块索引
    稠密索引因索引项与数据集的记录个数相同，空间代价大。为了减少索引项的个数，可以对数据集进行分块（类：图书分类），使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。
    分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：
    - 块内无序，即每一块内的记录不要求有序。
    - 块间有序
    对于分块有序的数据集，将每块对应一个索引项的索引方法叫做分块索引。
*** 倒排索引
    索引项的通用结构是：
    - 次关键码
    - 记录号表
    其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引（inverted index）。倒排索引源于实际应用中需要根据属性（或字段、次关键码）的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引。
** 二叉排序树
   二叉排序树（Binary Sort Tree）又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。
   - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。
   - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。
   - 它的左右子树也分别为二叉排序树。
** 平衡二叉树（AVL树）
   平衡二叉树（Self-Balancing Binary Tree or Height-Balanced Binary Search Tree）是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1，是一种高度平衡的二叉排序树。
   平衡因子BF（Balance Factor）：二叉树上节点的左子树深度减去右子树深度的值。
   最小不平衡子树：距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树。
** 多路查找树（B树）
   其每一个结点的孩子数可以多余两个，且每一个结点处可以存储多个元素。常见的4种特殊形式：2-3树、2-3-4树、B树和B+树。
*** 2-3树
    其中的每一个结点都具有两个孩子（称它为2结点）或三个孩子（称它为3结点）。
    一个2结点包含一个元素和两个孩子或没有孩子，且于二叉排序树类似，左低（值小）右高（值大）。
*** B树
    B 树 (8-悦的是一种平衡的多路查找树 ， 2 -3 树和 2-3-4 树都是 B 树的特例。结点最大的孩子数目称为 B 树的阶 (order) ，因此， 2-3 树是 3 阶 B 树， 2-3-4 树是4阶B树。
一个 m 阶的 8 树具有如下属性:
• 如果根结点不是叶结点，则其至少有两棵子树.
• 每一个非根的分支结点都有 k-l 个元素和 k 个孩子，其中 rm/21ζ k<mo 2.1
每一个叶子结点 n 都有 k-l 个元素，其中 rm/21< k< rtlo
• 所有叶子结点都位于同一层次。
• 所有分支结点包含下列信息数据( n，Ao，K，入 ，Kz，Az ， …，凡，A1J ，其中: K;
( i=1 ，2，… .n) 为关键字，且K;<民+ 1 (i 剖，2，…，川); A; (.i=0 ，2，…，0) 为指向
子树根结点的指针，且指针 A;斗所指子树中所有结点的关键字均小于 K，
(i=1 ，2，…，n，An所指子树中所有结点的关键字均大于K_n，n([m/2]-1\le n\le m-1)为关键字的个数(或n+1为子树的个数)。
*** B+树
一棵 m 阶的 B+树和 m 阶的 8 树的差异在于:
• 有 n 棵子树的结点中包含有 n 个关键字;
• 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指
针，叶子结点本身依关键字的大小自小而大顺序链接;
• 所有分支结点可以看成是索引，结点中仅含有其子树中的最大(或最小〉
关键字。
** 散列表查找（哈希表）概述
*** 散列表查找定义
散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得
每个关键字 key 对应一个存储位置 f (key) 。查找时，根据这个确定的对应关系找到
给定值 key 的映射 f (key) ，若查找集合中存在这个记录，则必定在 f ( key) 的位
置上 。
这里我们把这种对应关系 f 称为散列函数 ， 又称为哈希 (Hash) 函数。按这个思
想， 采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列
表或哈希表 (Hash 1ab剧 。 那么关键字对应的记录存储位置我们称为散列地址。
*** 散列表查找步骤
整个散列过程其实就是两步 。
( 1 ) 在存储肘，通过散列函数计算记录 的散列地址，并按此散列地址存储该记
录。
( 2 ) 当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散到地
址访问该记录 。
所以说， 散列技术既是一种存储方法，也是一种查找方法。
散列主要是面向查找的存储结构。
散列技术最适合的求解问题是查找与给定值相等的记录。
碰到两个关键字 key1\ne key2，但是却有f(key1) =f(key2)，这种现象我们称为冲突(oollision)，并把 key1和key2称为这个散列函数的同义词 (synonym) 0
*** 散列函数的构造方法
**** 直接定址法
    取关键字的某个线性函数值为散列地址，即
f(key)=a x key+b (a、b为常数}
这样的散列函数优点就是简单 、 均匀，也不会产生冲突，但问题是这需要事先知
道关键字的分布情况，适合查找表较小且连续的情况。由于这样的限制，在现实应用
中，此方法虽然简单，但却并不常用 。
**** 数字分析法
     数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布
且关键字的若干位分布较均匀，就可以考虑用这个方法。
**** 平方取中法
     这个方法计算很简单，假设关键字是 1234 ， 那么它的平方就是 1522756 ，再抽取
中间的 3 位就是 227 ，用做散列地址 。 再比如关键字是 4321 ，那么包的平方就是
18671041 ，抽取中间的 3 位就可以是 671 ，也可以是 71 0 ，用做散列地址。平方取中
法比较适合子不知道关键字的分布，而位数又不是很大的情况。
**** 折叠法
折叠法是将关键字从左到右分割成位数相等的几部分(注意最后一部分位数不够
时可以短些) ，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。
折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。
**** 除留余敢法
此方法为最常用的构造散列函数方法。 对于散列裴长为 m 的散列函数公式为:
f ( key) = key mod p (p 运 m)
mod 是取模(求余数)的意思 。 事实上，这方法不仅可以对关键宇直接取模，也
可在折叠、 平方取中后再取模。
很显然，本方法的关键就在于选择合适的 P ， P 如果选得不好，就可能会容易产生
同义词 。
因此根据前辈们的经验，若散列表表长为 m ， 通常 p 为小子或等于表长(最好接
近 m ) 的最小质数或不包含小子 20 质因子的合数。
**** 随机数法
选择一个随机数，取关键字的随机函数值为它的散列地址。也就是 f (key)
=random (key ) 。这里 random 是随机函数。当关键字的长度不等时，采用这个方法
构造散列函数是比较合适的。
*** 处理散列冲突的方法
**** 开放定址法
所谓的开放定址法就是一旦发生了冲突 ， 就去寻找下一个空的散列地址，只要散
列表足够大，空的散列地址总能找到，并将记录存入。
他的公式是 :
f(key) = (f(key)+d1) MOD m (d1=1.2 ，3,.......,m-1 )
**** 再散列函数法
**** 链地址法
**** 公共溢出区法
* 排序
** 排序的基本概念与分类
假设含有 n 个记录的序列为{r1.r2. ... ....rn} ， 其相应的关键字分别为{k1,k2，...,
kn}，需确定1，2, ……,n的一种排列p1,p2,……，pn，使其相应的关键字满足k_p1 \le k_p2 \le ...... \le k_pn(非递减或非递增)关系，即使得序列成为一个按关键字有序的序列{rp1,rp2,......,rpn}， 这样的操作就称为排序 。
*** 排序的稳定性
    也正是由于排序不仅是针对主关键字，那么对于次关键字，因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录，排序结果可能会存在不唯一的情
况，我们给出了稳定与不稳定排序的定义。
    假设 ki=kj ( 1\le i\le n，1\le j\le n，í\ne j)，且在排序前的序列中ri领先于rj(即i<j)。如果排序后ri仍领先于rj，则称所用的排序方法是稳定的;反之，若可能使得排序后的序列中rj领先ri，则称所用的排序方法是不稳定的。
*** 内排序与外排序
    根据在排序过程中待排序的记录是否全部被放置在内存中 ， 排序分为:内排序和外排序。
    内排序是在排序整个过程中，待排序的所有记录全部被就置在内存中 。 外排序是由于排序的记录个数太多 ， 不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。我们这里主要就介绍内排序的多种方法。
对于内排序来说，排序算法的性能主要是受 3 个方面影响:
    1.时间性能
    排序是数据处理中经常执行的一种操作，往往属于系统的核心部分，因此排序算法的时间开销是衡量其好坏的最重要的标志。在内排序中，主要进行两种操作:比较和移动 。 比较指关键字之间的比较，这是要做排序最起码的操作。 移动指记录从一个位置移动到另一个位置，事实上，移动可以通过改变记录的存储方式来予以避免(这个我们在讲解具体的算法时再谈)。总之，高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。
   2. 辅助空间
   评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间 。
   3. 算法的复杂性
   注意这里指的是算法本身的复杂度，而不是指算法的时间复杂度。显然算法过于复杂也会影响排序的性能。
   根据排序过程中借助的主要操作，我们把内排序分为:插入排序、交换排序、选择排序和周并排序。 可以说，这些都是比较成熟的排序技术，已经被广泛地应用于许
许多多的程序语言或数据库当中，甚至2们都已经封装了关于排序算法的实现代码。因此，我们学习这些排序算法的目的更多并不是为了去在现实中编程排序算法，而是
通过学习来提高我们编写算法的能力，以便于去解决更多复杂和灵活的应用性问题。
** 冒泡排序
*** 最简单排序实现
冒泡排序 (Bubble Sort) 一种交换排序，宫的基本思想是:两两比较相邻记录的
关键字，如果反序则交换，直到没有反序的记录为止.
