* 基础知识
  数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。
  数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。
  数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。
  数据项：一个数据元素可以由若干个数据项组成。数据项是数据的不可分割的最小单位。
  数据对象：是性质相同的数据元素的集合，是数据的子集。
  数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。
  数据结构可分为逻辑结构和物理结构。
  逻辑结构：是指数据对象中数据元素之间的相互关系。有以下四种结构：
  - 线性结构：线性结构中的数据元素之间是一对一的关系。
  - 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。
  - 图形结构：图形结构的数据元素是多对多的关系。
  - 集合结构：集合结构的数据元素除了同属于一个集合外，它们之间没有其他关系。
  逻辑结构是针对具体问题的，是为了解决某个问题。在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。
  物理结构，也叫做存储结构，是指数据的逻辑结构在计算机中的存储形式。数据的存储结构应正确反映数据元素之间的逻辑关系。
  数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

  从程序角度：编程 = 数据结构 + 算法 + 程序设计语言
  从软件工程角度： 还需加上 项目管理、质量管理、代码规范等
** 常用算法
   算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。
   算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。
*** 递推算法
    通过已知条件，利用特定关系得出中间推论，逐步递推，直至得到结果为止。利用现有信息得到新的信息是递推算法的核心。
    递推算法可分为顺推法和逆推法两种。
    1. 顺推法
       从已知条件出发，逐步推算出要解决问题的方法。
    2. 逆推法
       从已知的结果出发，用迭代表达式逐步推算出问题开始的条件，即顺推法的逆过程。
*** 枚举法
    也称为穷举法。在解决某些问题时，可能没有办法按一定的规律从众多的候选答案中找出正确的解，可使用循环语句和条件语句逐步验证候选答案的正确性，从而得到正确的答案。主要利用计算机的高速运算性能。
*** 递归算法
    一种直接或间接的调用自身的算法。
    递归算法的具体实现过程一般是通过函数或子过程来完成，在函数或子过程的内部，编写代码直接或间接的调用自身，即可完成递归操作。其实质是将求解的问题转化为规模缩小的同类问题的子问题。以小化大，分而治之。
*** 贪婪算法
    总是做出在当前看来最好的选择，做出局部最优解，意在局部最优（贪婪）达到全局最优。
    思路：从问题的某一个初始解出发逐步逼近给定的目标，以尽可能块的求得更好地解。当达到算法中的某一步不能再继续前进时，就停止算法，给出近似解。不回溯。
*** 试探法
    也称为回溯法，是一种系统的搜索问题解的方法。典型场景：下棋
*** 模拟算法
   使用计算机模拟生成日常生活中的相关数据。
   在程序设计语言中，可使用随机函数来模拟自然界中发生的不可预测情况。C语言中使用srand()和rand()函数生成随机数。其中srand用来初始化随机数发生器，然后使用rand()函数生成随机数，要使用这两个函数，需要在源程序中包含time.h头文件。
** 算法的评价
   四原则：
   正确性，高效性，健壮性，可读性。高效性是主要标准。
   通常认为，一个算法的“工作量”可以靠代码中的关键部分来确定，这些关键部分称为基本操作，通过统计算法中基本操作重复执行的次数就可近似地得到算法的执行效率，用O(n)表示，称为时间复杂度。
   算法时间复杂度定义：
   在进行算法分析时，语句总的执行次数T(n)时关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。这样用大写O()来体现算法时间复杂度的记法，称为大O记法。
   推导大O阶方法：
   1. 用常数1取代运行时间中的所有加法常数。
   2. 在修改后的运行次数函数中，只保留最高阶项。
   3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。
   得到的结果就是大O阶。
注：在分析一个算法的时间复杂度时，一般可考虑平均情况和最坏情况。对于时间复杂度的平均值，往往需要较复杂的统计计算。因此大部分情况下都以最坏时间复杂度为准来考查算法的时间复杂度。
* 简单数据结构
  算法用来处理对应的数据，被处理的数据都必须按一定的规则进行组织。当数据之间存在一种或多种特定关系时，称这些关系为结构。
** 最基本的数据结构：线性表
   线性表是一个线性结构，它是一个含有n个结点（数据元素）的有限序列，不同线性表的数据元素可以不同，但同一线性表，各数据元素必须具有相同的数据类型，数据元素长度相同。
   特征：
   + 有且只有一个首元素
   + 有且只有一个尾元素
   + 除尾元素外，其余元素均有唯一的后继元素
   + 除首元素外，其余元素均有唯一的前驱元素
   在计算机中保存线性表时，根据存储方式的不同，分为顺序存储结构和链式存储结构。顺序存储结构的称为顺序表，链式存储结构的称为链表。
*** 顺序表
    用一组地址连续的存储单元依次保存线性表中的数据元素。
    特点：易于访问，不易控制。
*** 链表
    采用动态存储分配的一种结构，可以根据需要申请内存单元。C语言中可以用malloc函数动态分配结点，删除结点时，使用free函数释放内存空间。
    注：C语言不支持自动回收动态分配到空间。
    为了表示每个数据元素与其直接后继数据元素之间的逻辑关系，对任一数据元素来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素的存储映像，称为结点（Node）。n个结点链结成一个链表。即为线性表的链式存储结构。
    把链表中第一个结点的存储位置叫做头指针。有时，我们为了更加方便的对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。
    特点：易于操作，不易访问。
*** 静态链表
    用数组描述的链表叫做静态链表，这种描述方法也叫做游标实现法。主要用于给没有指针和引用的程序语言的一种实现单链表的方法。
    数组的第一个和最后一个元素作为特殊元素处理，不存数据。通常把未被使用的数组元素称为备用链表。而数组第一个元素，即下标为0的元素的cur（游标）存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点的作用。
** 先进先出结构：队列
   队列是一种特殊的线性表，只允许在表的前端(队头,front)进行删除操作，在表的后端(队尾,rear)进行插入操作。当队列中没有元素时，称为空队列。队列是一种先进先出(Firest in Firest Out)的线性表，简称FIFO。
   循环队列满的条件：(rear+1) % QueueSize == front
        其空的条件：front == rear
   循环队列的长度公式：(rear - front + QueueSize) % QueueSize
** 后进先出结构：栈
   栈是一种特殊的线性表，只能在一端进行操作，称为栈顶，另一端称为栈底。栈又称为后进先出(Last in Firest Out)的线性表，简称LIFO结构。
** 串
   串（string）是由零个或多个字符组成的有限序列，又叫字符串。
   串中的字符数目n称为串的长度。零个字符的串称为空串（null string）。
   子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。
   子串在主串中的位置是子串的第一个字符在主串中的序号。
   KMP模式匹配算法
* 复杂数据结构
** 层次关系结构：树
   一个结点有一个前驱和多个后继。树（Tree）是n(n \ge 0)个结点的集合，集合中有一个称为根（root）的特殊结点，在根结点下分布着一些互不相交的集合，每一个集合又是一个树，称为根结点的子树。n=0时称为空树。
   在一棵树中，有且仅有一个结点没有前驱，这个结点就是树的根结点。
   除根结点外，其余每个结点有且仅有一个前驱。
   每个结点可以有任意多个后继。
   相关术语：
   - 父结点/子结点/兄弟结点：每个结点的子树的根称为该结点的子结点，相应的，该结点被称为子结点的父结点，具有同一父结点的结点称为兄弟结点。
   - 结点的度：结点拥有的子树的数量称为该结点的度。
   - 树的度：指该树中结点的最大度数。
   - 叶结点和分支结点：树中度为零的结点称为叶结点或终端结点，度不为零的结点称为分支结点或非终端结点。
   - 结点的层数：结点的层数从树根开始计算。
   - 树的深度：一棵树中结点的最大层数称为树的深度。
   - 有序树和无序树：树中各结点的子树（兄弟结点）是按一定次序从左向右排列的，称为有序树，否则称为无序树。
   - 森林：森林（forest）是m（m>0）棵互不相交的树的集合。
** 二叉树
    任意结点最多只能有两个子结点的树称为二叉树。
    二叉树与树的两个主要区别：
    - 树中结点的最大度数没有限制，而二叉树结点的最大度数为2
    - 树的结点无左右之分，而二叉树的结点有左右之分，是有序树。
    两个特殊类型的二叉树：
    - 满二叉树：在二叉树中，除最下一层的叶结点外，每次的结点都有2股子结点，就构成了满二叉树。
    - 完全二叉树：除二叉树最后一层外，其他各层的结点数都达到最大个数，且最后一层从左向右的叶结点连续存在，只缺右侧若干结点，就是完全二叉树。
    满二叉树是完全二叉树，而完全二叉树不一定是满二叉树。
*** 性质
    1. 在二叉树中，第i层的结点总数最多有2i-1个结点。
    2. 深度为k的二叉树最多有2k-1个结点(k \ge 1)，最少有k个结点。
    3. 对于一颗二叉树，如果其叶结点数为n0，而度为2的结点总数为n2，则n0=n2+1。
    4. 具有n个结点的完全二叉树的深度k为[log2n]+1。
    5. 有n个结点的完全二叉树各结点如果用顺序存储，对任意结点i，有如下关系：
       - 如果i \ne 1，则其父结点的编号为i/2;
       - 如果2*i \le n，则其左子树根结点的编号为2*i，若2*i > n，则无左子树；
       - 如果2*i+1 \le n，则其右子树根结点的编号为2*i+1，若2*i+1 > n，则无右子树。
*** 存储
    有两种存储结构，顺序存储结构和链式存储结构。顺序存储适合完全二叉树。
*** 遍历二叉树
    按一定的规则和顺序走遍二叉树的所有子树，使每一个结点都被访问一次，而且只被访问一次。
    D表示根结点，L表示左子树/R表示右子树，对其遍历有三种方式:
    - 先序遍历（DLR）：称为先根次序遍历，即先访问根结点，再按先序遍历左子树，最后按先序遍历右子树。
    - 中序遍历（LDR）：称为中根次序遍历，即先按中序遍历左子树，再访问根结点，最后按中序遍历右子树。
    - 后序遍历（LRD）：称为后根次序遍历，即先按后序遍历左子树，在按后序遍历右子树，最后访问根结点。
*** 线索二叉树
    由二叉树的性质可知，对于一颗具有n个结点的二叉树，对应的二叉链表中共有2n个指针域，其中n-1个用于指向除根结点外的n-1个结点，另外n+1个指针域为空。可以利用二叉链表中的这些空指针域来存放结点的前驱和后继。将每个结点中空的左指针域或右指针域分别用于指向结点的前驱和后继的指针域称为线索，其中，在空的左指针域中存放的指向其前驱结点的指针称为左线索，反之称为右线索。
    这种加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。
    在一个线索二叉树中，为了区别每个结点的左、右指针域所存放的时子树指针，还是线索，必须在结点结构中增加两个标志域：
    一个左线索标志域lflag、另一个是右线索标志域rflag。若某个标志为1，则表示对应的指针域为线索，否则，为子树指针。
    将二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化。按某种遍历次序将二叉树线索化的实质是：按该次序遍历二叉树，在遍历过程中用线索取代空指针。
*** 赫夫曼树
    从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度。树的路径长度就是从树根到每一个结点的路径长度之和。
    对于带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。带权路径长度WPL最小的二叉树称作赫夫曼树，也称为最优二叉树。
** 图
*** 定义
    图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E),其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。
    无向边：若顶点v_i 到v_j 之间的边没有方向，则称这条边为无向边(Edge)，用无序偶对(v_i, V_j)来表示，如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。
    有向边：若从顶点v_i 到v_j 的边有方向，则称这条边为有向边，也称为弧，用有序偶对<v_i, v_j>来表示，v_i 称为弧尾(tail),v_j 称为弧头(head)。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。
    在图中，若被存在顶点到其自身的边，且同一条边被重复出现，则称这样的图为简单图。
    在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有$n*(n-1)/2$。
    在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。
    与图的边或弧相关的数字叫做权（weight），带权的图通常称为网（network）。
    在无向图中，顶点v的度（degree）是和v相关联的边的数目，记为TD(v)。
    在有向图中，以顶点v为头的弧的数目称为v的入度（InDegree）,记为ID(v)，以v为尾的弧的数目称为v的出度（OutDegree），记为OD(v)，顶点v的度为TD(v) = ID(v) + OD(v)。边数为各顶点的入度或出度和。
    从顶点i到顶点j的路径的长度为路径上的边或弧的数目。
    第一个顶点到最后一个顶点相同的路径称为回路或环（Cycle）。顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路，称为简单回路或简单环。
    连通图：在无向图中，如果从顶点v_i 到顶点v_j 有路径，则称v_i 和v_j 是连通的。如果图中任意两点都是连通的，则称G是连通图。
    具有n个顶点的无向图，当有(n-1)(n-2)/2+1条边时即可确保它是一个连通图。
    无向图中的极大连通子图称为连通分量。
    强连通图：在有向图中，如果对于每一对v_i 、v_j, v_i \neq v_j, 从v_i 到v_j 和从v_j 到 v_i 都存在路径，则称G是强连通图。
    判断一个有向图是否强连通，要看从任一顶点出发是否能够回到该顶点。
    有向图中的极大强连通子图称作有向图的强连通分量。
    具有n个顶点的有向图最多有n个强连通分量。
    生成树：连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。
    具有n个顶点和e条边的无向图是一个森林，则该森林有n-e棵树。
    如果一个有向图恰有一个顶点的入度为0，其余顶点的入度为1，则是一颗有向树。一个有向树的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。
*** 图的存储
    邻接矩阵:图的邻接矩阵存储方式是用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵，顶点nxn的方阵）存储图中的边或弧的信息。
    邻接表：将数组与链表相结合的存储方法称为邻接表。
